%----------------------------------------------------------------------------
\chapter{Tervezés}
%----------------------------------------------------------------------------
\section{Kommunikáció}

A kommunikáció csatornánként 2 db modem segítségével történik, a modemek egymás közt vezeték nélkül csatlakoznak, felhasználói oldalon soros portot biztosítanak. Így az elkészítendõ programnak elég csak a soros port jeleinek vételével foglalkoznia. A modemek adatátviteli sebessége változó lehet, így azt a felhasználó egy listából választhatja csatlakozás elõtt. Átalakítóval lehetõség adatik USB-n keresztül soros port megvalósítására, így könnyen kezelhetõvé válik a periféria illesztés

\section{Adatok fogadása}

A redundanciából következõen külön, külön kell kezelni a 2 párhuzamos csatornán kapott adatokat. Mivel aszinkron módon érkeznek a csomagok, így kettõ tároló kell, mely a legutóbb küldötteket tárolja egy FIFO listában.

\subsection{Protokoll}

Az adatokat a repülõgép 2 Hz-s frekvenciával küldi, ezek csomagokban érkeznek, melyeknek a felépítése:

\begin{figure}[H]
 \hspace*{-2cm}  
	\resizebox{17cm}{!}{
		\includegraphics{figures/downprot.png}}
\end{figure}


%\begin{table}[H]
%\begin{center}
%		\begin{tabular}{| l | l | l | l |l |}
%			\hline    bájt index 	& leírás 				& típus & skálázás 		       & offset \\ \hline
%				1 					& start 				& char(fix 'U') &   					       &    						 \\ \hline
%				2 					& start 				& char(fix 'U') &   					       &    						 \\ \hline
%				3						& start 				& char(fix 'T') &   					       &    						 \\ \hline
%				4 					& idõ  					& uint32 				& 10000 			       & 0  						 \\ \hline
%				8 					& magasság 			& uin16 				& 0x7fff/1000	       &    						 \\ \hline
%				\dots 			&   						&   						&   					       &    						 \\ \hline
%				\dots 			&   						&   						&   					       &    						 \\ \hline
%				\dots 			&   						&   						&   					       &    						 \\ \hline
%				\dots 			&   						&   						&   					       &    						 \\ \hline
%				\dots 			&   						&   						&   					       &    						 \\ \hline
%				\dots 			&   						&   						&   					       &    						 \\ \hline
%				\dots 			&   						&   						&   					       &    						 \\ \hline
%				\dots 			&   						&   						&   					       &    						 \\ \hline
%				\dots 			&   						&   						&   					       &    						 \\ \hline
%				\dots 			&   						&   						&   					       &    						 \\ \hline
%				\dots 			&   						&   						&   					       &    						 \\ \hline
%				\dots 			&   						&   						&   					       &    						 \\ \hline
%				TODO & északi irány 1/2 	& unsigned short & 0x7FFF/400 &  200 \\ \hline
%				28 & keleti irány 1/2 & unsigned short & 0x7FFF/400 &  200 \\ \hline
%				30 & lefelé irány 1/2 & unsigned short & 0x7FFF/400 &  200 \\ \hline
%			
%				\dots &   &   &   &    \\ \hline
%			\end{tabular}
%\end{center}
%	\caption{Fogadás protokollja}
% \label{tab:down}
%\end{table}

A skálázás és offset képzés azért szükséges, hogy az adott szélességen (8, 16, 32 bit) minél több biten legyen ábrázolva egy érték, mivel kis változások esetén a Hamming-távolság\footnote{Bináris számok XOR képzésével kapott 1-esek száma} kicsi lenne az eredeti számábrázoláson. Ahol szükséges, ott a  visszakódolás az alábbi formában történik : \\
\textit{eredeti  = (nyers adat/skálazás) - offset} \\
Az értékek megfelelõ kiválasztása a minél nagyobb szétszóráshoz szükséges.

\section{Adatok küldése}

A repülõgép által lerepülendõ feladat útvonalpontjait hasonlóképpen, mint az adatok fogadását, vezeték nélküli csatornán küldjük fel. A feltöltendõ adat küldésének protokollja létfontosságú, mivel ha valamilyen hiba kerül a kommunikációba akkor az akár végzetes is lehet. Gondolok itt olyan hibára, hogy egy fordulópont koordinátája úgy kerül feltöltésre, hogy az kiesik a repülõ hatósugarából és ezzel nem számolva, lemerül a tápellátást szolgáló akkumulátor. Az ilyen hibák ellen célszerû a feltöltés protokolljába hibadetektálást építeni, hogy ezek a feldolgozás elõtt derüljenek ki.

Felmerül a kérdés, hogy a küldés mikor engedélyezett, a felszállás elõtt vagy repülés közben is? Láthattuk néhány megoldásban, hogy lehetõség van az útvonal módosítására menet közben is, ez egy jó opció, így érdemes ezt is megvalósítani. Egyetlen probléma ennek mikéntje, ha csak egy pont koordinátáját módosítjuk, akkor csak ezt vagy az összeset küldjük? Ennek egyik megoldása az lehet, hogy korlátozzuk az elõször feltöltött pontok számára és az összes pontot újra elküldjük. A módosítás feldolgozását rábízzuk a fedélzeti implementációra, hogyha egy ponton áthaladt, akkor az utólag hiába lett módosítva, a következõ fordulópont felé halad. További stratégiák is elképzelhetõek, de a további fejezetekben taglaltak miatt, ezt érdemes választani.

\subsection{Protokoll}

Több megoldás is lehetséges a fordulópontok feltöltésére:
\begin{itemize}
\item Rögzített maximális darabszám elküldése egy csomagban
\item Változó darabszám esetén egy fordulópont egy csomagban
\end{itemize}


Az elsõ megoldásban rögzítenénk a fordulópontok maximális számát. Mely azt eredményezné, hogy egy csomagban el lehetne küldeni az egész lerepülendõ feladatot. Ha egy pont koordinátájának ábrázolására elég 2*4 byte, így ha feltételezünk egy 10 pontot tartalmazó (10*2*4 byte adat) csomagot, akkor annak mérete fejléccel (3 bájt), checksum mezõvel (2 bájt) 85 bájt. Ehhez hozzájönne még a pontok száma, mely a fogadó oldali feldolgozást segítené, ennek mérete 1 bájt.


Másik lehetõségnél bármennyit (N db) lehetne feltölteni: egy csomag szerkezete: fejléc, küldendõ pontok száma, aktuális pont sorszáma, koordinátái, checksum. Ha a  küldendõ pontok száma és az aktuális pont sorszáma megegyezik és megérkezett minden csomag akkor ACK-val válaszol ha kész a feltöltés. Ez hibakezelés szempontjából kedvezõbb, mivel ha egy pont sorszáma nem egyezik meg az elvárttal, akkor újraküldés kérésével elég csak az adott pont újraküldésével terhelni a csatornát.

Mivel az eddig használt megoldásban a kódba ,,bele volt égetve'' az útvonalterv, mely 5-6 pontot tartalmazott, az elsõ megoldás tûnik kedvezõbbnek. Fogadó oldalon is könnyebb egy ilyen lehetõségre felkészíteni. Ha esetlegesen a jövõben több fordulópontont feltöltésére lesz igény, az is megoldható módosításokkal.

A feltöltés során mindkettõ csatlakoztatott modem segítségével redundánsan küldjük el az elõállított csomagot. Ha a csomag sértetlenül megérkezett, ACK jelzéssel válaszolnak, melyet fogadunk és visszajelezzük a kezelõnek.

Egy 86 bájtos csomag tartalma:
\begin{table}[H]
	\begin{center}
			\begin{tabular}{| l | l | l | l |l |}
				\hline
				bájt index 	& leírás 				& típus 				& skálázás 		& offset  \\ \hline
				0 					& start 				& bájt(fix 'G') &   					&    			\\ \hline
				1 					& start 				& bájt(fix 'P') &   					&    			\\ \hline
				2						& start 				& bájt(fix 'S') &   					&    			\\ \hline
				3 					& pontok száma	& bájt    			& 			 			&    			\\ \hline
				4 					& pontok[0].lat & uin32 				& UInt32.MaxValue/360	&  180		\\ \hline
				\dots 			&   						&   						&   					&    			\\ \hline
				8 					& pontok[0].lon & uin32 				& UInt32.MaxValue/360	&  180		\\ \hline
				\dots 			&   						&   						&   					&    			\\ \hline
				12 					& pontok[1].lat & uin32 				& UInt32.MaxValue/360	&  180		\\ \hline
				\dots 			&   						&   						&   					&    			\\ \hline
				16 					& pontok[1].lon & uin32 				& UInt32.MaxValue/360	&  180		\\ \hline
				\dots 			&   						&   						&   					&    			\\ \hline
				84 					& checksum 1/2	& uin16 				& 						&  				\\ \hline
				85 					& checksum 2/2 	& uin16 				& 						&  				\\ \hline

			\end{tabular}
	\end{center}
	\caption{Küldés protokollja}
	\label{tab:up}
\end{table}

Felmerülhet a kérdés, hogy a feltöltés ezzel a protokollal elég hibatûrõ-e, mivel a fogadás protokollja is hasonló hibadetektálást biztosít, így elégségesnek tûnik, tovább, ha a küldés megfelelõen lezajlott, kapunk visszajelzést. Ha ez elmaradna, akkor lehetõség van az üzenet újbóli elküldésre.

\section{Grafikus felület}

Az elõzõ fejezetben ismertetett grafikus felületekbõl levonva a következtetéseket, nyilvánvaló, hogy a GUI kialakításában fontos a repülõgép aktuális pozíciójának térképen való mutatása, az repülési állapot könnyen értelmezhetõ megjelenítése, illetve az esetlegesen elõforduló problémák feltûnõ jelzése.

\subsection{Fõképernyõ}

A fõképernyõn látható lesz a repülõgép aktuális pozíciója és iránya. A pozicionálást segítendõ, egy térkép lesz egy repülõgép ikon hátterében. Ez a rész a képernyõ kb. 2/3-át fogja elfoglalni. Az oldalsó sávban a ``Glass Cockpit'' kerül kialakításra, ez a nézet tartalmazza a gép aktuális sebességét, iránytû segítségével irányát, magasságát, emelkedésének sebességét. Valószínûleg ez a képernyõ lesz legnagyobb százalékban használva, így a kritikus hibákról itt kell feltûnõ értesítést adni. Melyet a háttérben dolgozó hibadetektáló algoritmus vált ki. Az értesítés egy felugró ablak lenne, mely tartalmazza, mely érték hibájából keletkezett.

\subsection{Tervezés képernyõ}

Ezen a képernyõn a felhasználó kijelölheti a lerepülendõ útvonalhoz tartozó fordulópontokat, melyet csatlakozás után aszinkron módon feltölthet a repülõre. Mivel a kommunikációs protokoll 10 pontot enged meg, így ennél többet itt ki sem jelölhet, a lerakott pontok helyét a megszokott Google Maps-hoz hasonló módon hosszan kattintva átrakhatónak kell lennie, illetve köztes pontoknak törölhetõeknek kell lenniük. Láthattuk, hogy érdemes a kijelölt útvonal hosszáról tájékoztatni a felhasználót, így ez egy hasznos funkció.

\subsection{Diagnosztikai képernyõ}

A 2 porton érkezõ dekódolt értékek látszódnának 2 oszlopban, mellettük egy hibaérték, mely a különbözõ hibatípusok hibaszámának összege lenne. 

\subsubsection{Hibatípusok}
\begin{itemize}
\item beragadás
\item túl nagy változás
\item túl nagy különbség a 2 vett értéken
\end{itemize}

Ezek feldolgozására 2 FIFO sort kell alkalmazni, melyek visszamenõleg tárolják a beérkezõ értékeket. Ez azért szükséges, mivel így a túlságosan kiugró értékeket detektálni lehet, illetve, ha az egész sorban ugyanazok az értékek vannak, gyanús a beragadás esélye.
A harmadik esetben sajnos nem lehetséges a ``jó'' kiválasztása, mivel nem tudjuk, melyik modembõl érkezett adat a megfelelõ. Ezt csak háromszorozással és többségi szavazással lehetne megoldani. Így a kettõ érték átlagát lehet csak felhasználni.

\subsection{Terminál képernyõ}

Lehetõség nyílik a fogadott csomagok hexadecimális vagy decimális formában történõ megjelenítése, így az operátor alacsony szinten megbizonyosodhat a kapcsolat létrejöttében, mivel láthatja a csomagok beérkezését. Ha a fejléc a csomag elején látszódik, akkor mûködnie kell a további dekódolásnak, melyet a többi nézet használ fel. Ha nem lát itt adatokat, akkor ellenõrizheti, hogy valóban jó portot illetve adatsebességet választott-e ki.

\section{Használt technológiák bemutatása}

A programot C\# nyelven, Microsoft Visual Studio 2010-es verziójával készítem, a használt .NET keretrendszer verziója: 4.5.

\subsection{.NET}

\begin{figure}[H]
	\centering
	\resizebox{10cm}{!}{ 
		\includegraphics{figures/net.png}} 
	\caption{}
	\label{fig:net}
\end{figure}

\cite{bib:netstart} A .NET egy menedzselt végrehajtási környezetet biztosító keretrendszer, mely számos szolgáltatást nyújt a benne futtatott programoknak. Két fõ részbõl áll: CLR\footnote{Common Language Runtime (közös nyelvi futtatókörnyezet) }, mely a programok végrehajtásáért felelõs és a .NET BLR\footnote{Base Class Library}, mely tesztelt, újra felhasználható programkönyvtárakat tartalmaz.


\subsubsection{Common Language Runtime} 

\cite{bib:net} A menedzselt környezetet a CLR biztosítja, a memóriakezelést kiveszi a programozók feladatai közül, mely az egyik legnagyobb odafigyelést igényelte, további feladata a kód végrehajtása, verifikációja, fordítása. Garbage Collector nevû memóriafelszabadítást végzõ eszköze automatikusan törli a memóriából a már nem hivatkozott elemeket.

\subsubsection{Base Class Library}

API\footnote{Application Programming Interface, mely elõre megírt komponensek használatához biztosít interfészt}-k összesége, célja hogy megkönnyítse és gyorsítsa fejlesztés folyamatát. A feladatom megoldásához egyik legfontosabb osztály a \textit{SerialPort}\cite{bib:serial} osztály, mely megkönnyíti a soros port kezelését.

\subsubsection{Common Language Specification} 

\cite{bib:aut} A .NET nyelvfüggetlen, így a keretrendszer szolgáltatásai hozzáférhetõek minden nyelv számára, mely nyelvi specifikációnak megfelel. Többek között ezek a nyelvek támogatottak: C\#, C++, Visual Basic.

\subsubsection{Windows Forms} 

Grafikus megjelenítést biztosít az alkalmazásoknak, különbözõ elemek (beviteli mezõ, gomb, kép, választó lista) helyezhetõek el rá. \cite{bib:gdi} GDI\footnote{Graphic Device Interface} segítségével történik a kirajzolás. A GDI olyan függvények gyûjteménye, amelyek a grafikus elemek (görbék, alakzatok, BMP képek) megjelenítését, szövegek kiíratását teszi lehetõvé. A GDI+ ennek továbbfejlesztett változata, mely képes ezen elemek manipulációjához alkalmas mátrixtranszfomációkat kezelni és egyéb képformátumok támogatása is megjelent.

\subsubsection{C\# nyelv} 
\cite{bib:aut} A C/C++ család elsõ valódi objektumorientált tagja, a keretrendszer nagy része C\#-ban készült.
Más nyelvekkel összehasonlítva tisztább, mint a C++, nagy hasonlóságot mutat a Java nyelvvel.

