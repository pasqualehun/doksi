%----------------------------------------------------------------------------
\chapter{Megvalósítás}
%--------------------------------------

Az elõzõ fejezetekben összegyûjtöttem a megvalósításhoz szükséges információkat, tervezési lépéseket. Ebben a fejezetben a konkrét implementációt fogom bemutatni.


\section{Program felépítése}

A \figref{class} ábrán láthatóak a programban használt osztályok. A \textit{Program} statikus osztály a main függvényt, mint belépési pontot tartalmazza. Ez példányosítja az \textit{Instruments} osztályt, mely a különbözõ \textit{View}-ok megjelenítéséért felelõs.

\begin{figure}[H]
	\centering
	\resizebox{13cm}{!}{
		\includegraphics{figures/classdiagram.png}}
	\caption{}
	\label{fig:class}
\end{figure}

\subsection{Kapcsolódás megvalósítása}

Sorosportok, SerialUtil

\subsection{Redundáns adatok feldolgozása}

DataElement...


\section{Megjelenítés}

\subsection{Fõképernyõ}

Láthattuk a HappyKillmore (\sectref{happy} fejezet) minden mûszert külön View-ként valósít meg, így ezt a megoldást célszerû használni. Elkészítettem a magasságmérõ, emelkedésjelzõ, sebességmérõ és iránytû UserControll-t melyek tervezõ nézetben ``Drag and Drop'' technológiával a megfelelõ helyre húzható és könnyen beköthetõ.

\subsubsection{Sebességmérõ}
A View egy UserControll-ból származik, annak a OnPaint() metódusát írom felül, melyben a mûszer különbözõ elemeit pozicionálom a megfelelõ helyre. Az OnPaint() függvény minden olyan esetben meghívódik, mikor valamely része érvénytelenné, nem láthatóvá válik. Ekkor szükséges az elem újra rajzolása, ezt mi a View Invalidate() metódusával explicit is kiválthatjuk.
GDI+ segítségével egy piros kört rajzolok

\subsubsection{Iránytû}
Rotate....



Bal oldalon az elõbb létrehozott UserControllok megjelenítése és elhelyezése a \figref{fokepernyo} ábrán látható. A terület nagyobb részét a térkép foglalja el, melyen a repülõgép aktuális pozíciója látható, illetve a múltban fogadott koordináták tört vonallal összekötve, mely a lerepült útvonalat ábrázolja. A program minimális méretében minden mûszer látszódik, a méret módosításával ezek fix pozícióban maradnak, a jobb oldali térkép a jobb alsó sarokhoz van horgonyozva, így ha nagyobb területen szeretné bárki is szemlélni a térképet, akkor látszódik ennek a megoldásnak az elõnye.

\subsubsection{Kapcsolódás}
Folyamatosan látszódik...

\begin{figure}[H]
	\centering
	\resizebox{15cm}{!}{
		\includegraphics{figures/fokepernyo.png}}
	\caption{}
	\label{fig:fokepernyo}
\end{figure}

\subsection{Tervezés képernyõ}

\begin{figure}[H]
	\centering
	\resizebox{15cm}{!}{
		\includegraphics{figures/tervkepernyo.png}}
	\caption{}
	\label{fig:tervkepernyo}
\end{figure}

\section{Diagnosztikai képernyõ}


\section{fejlesztés menete}
A modembõl érkezõ adatokat soros porton keresztül fogadja a program, a tesztkörnyezet felállításához HIL adatok szolgáltak. A küldött log fájlokat egy programmal beolvasom és egy \cite{bib:null}null-modem segítségével sorosporton keresztül küldöm a megfelelõ portra. 

\begin{figure}[!ht]
	\centering
	\resizebox{10cm}{!}{
		\includegraphics{figures/comnull.png}}
	\caption{}
	\label{fig:comnull}
\end{figure}

Beállítottam 2 párt, COM20-COM21 és COM10-COM11 közt, a pároson küldöm, páratlanon fogadom az üzeneteket. 

\begin{figure}[!ht]
	\centering
	\resizebox{10cm}{!}{
		\includegraphics{figures/sorossend.png}}
	\caption{}
	\label{fig:sorossend}
\end{figure}

153 bájtos egy csomag, melyet egy UUT  3 bájtos fejléc és egy 2 bájtos checksum zár. A checksum a hasznos bájtok 16 bitre csonkolt összege. Minden fogadott csomagnál, a feldolgozás elõtt kiszámolom az összeget és ellenõrzöm, az egyezést, a rossz csomagok egyelõre eldobásra kerülnek.

\begin{figure}[!ht]
	\centering
	\resizebox{10cm}{!}{
		\includegraphics{figures/xvi.png}}
	\caption{}
	\label{fig:xvi}
\end{figure}

Fogadó oldalon a két sorosport aszinkron ír 1-1 byte tömböt, melybõl egy dekódoló függvénnyel nyerjük ki a sebesség, pozíció, irány, stb. adatokat.

\begin{verbatim}
public double[] Decode(byte[] array)
\end{verbatim}

Ebben a függvényben ellenõrzöm, a checksum-ot, illetve a kezdõ UUT bájt hármast.
Mivel bájtosával lehet feldolgozni az adatokat, így pl. a 4 bájtos idõbélyeget 4 db egymás után jövõ bájtból kell összerakni:

\begin{verbatim}
uint ido = (uint)array[3]<<24 | (uint)array[4]<<16 |
(uint)array[5]<<8 | (uint)array[6];
\end{verbatim}

Ugyanígy folytatódik az adatok feldolgozása, az elõre megadott protokoll szerint.


