%----------------------------------------------------------------------------
\chapter{Megvalósítás}
%--------------------------------------

Az elõzõ fejezetekben összegyûjtöttem a megvalósításhoz szükséges információkat, tervezési lépéseket. Ebben a fejezetben a konkrét implementációt fogom bemutatni.

\section{.NET}
C\# nyelven szükséges a program implementálása, a .NET keretrendszer szerencsére sok API\footnote{Application Programming Interface, mely elõre megírt komponensek használatához biztosít interfészt}-t biztosít, hogy megkönnyítse és gyorsítsa fejlesztés folyamatot.
A grafikus megjelenítéshez GDI-t használhatok, illetve a soros porti kommunikációra a SerialPort osztály adta lehetõségeket.

Fejlesztésre a Microsoft Visual Studio 2010-es IDE-t használok .NET 4.5-tel.

\section{Program mûködése}

\begin{figure}[H]
	\centering
	\resizebox{10cm}{!}{
		\includegraphics{figures/classdiagram.png}}
	\caption{}
	\label{fig:class}
\end{figure}

\subsection{Kapcsolódás megvalósítása}

Sorosportok, SerialUtil

\subsection{Redundáns adatok feldolgozása}

DataElement...


\section{Megjelenítés}

\subsection{Fõképernyõ}

Láthattuk a HappyKillmore (\sectref{happy} fejezet) minden mûszert külön View-ként valósít meg, így ezt a megoldást célszerû használni. Elkészítettem a magasságmérõ, emelkedésjelzõ, sebességmérõ és iránytû UserControll-t melyet a tervezõ nézetben ``Drag and Drop'' technológiával a megfelelõ helyre húzható és könnyen beköthetõ.

\subsubsection{Sebességmérõ}
Kör megoldása

\subsubsection{Iránytû}
Rotate....



Bal oldalon az elõbb létrehozott UserControllok megjelenítése és elhelyezése a \figref{fokepernyo} ábrán látható. A látható terület nagyobb részét a térkép foglalja el, melyen a repülõgép aktuális pozíciója látható, illetve a múltban fogadott koordináták tört vonallal összekötve, mely a lerepült útvonalát ábrázolja. A program minimális méretében minden mûszer látszódik, a méret módosításával ezek fix pozícióban maradnak, a jobb oldali térkép a jobb alsó sarokhoz van horgonyozva, érdemben ezen látszódik ennek a megoldásnak az elõnye, mivel ha nagyobb területen szeretné bárki is szemlélni a térképen, az kirakható teljes képernyõre.

\subsubsection{Kapcsolódás}
Folyamatosan látszódik...

\begin{figure}[H]
	\centering
	\resizebox{15cm}{!}{
		\includegraphics{figures/fokepernyo.png}}
	\caption{}
	\label{fig:fokepernyo}
\end{figure}

\subsection{Tervezés képernyõ}

\begin{figure}[H]
	\centering
	\resizebox{15cm}{!}{
		\includegraphics{figures/tervkepernyo.png}}
	\caption{}
	\label{fig:tervkepernyo}
\end{figure}

\section{Diagnosztikai képernyõ}


\section{fejlesztés menete}
A modembõl érkezõ adatokat soros porton keresztül fogadja a program, a tesztkörnyezet felállításához HIL adatok szolgáltak. A küldött log fájlokat egy programmal beolvasom és egy \cite{bib:null}null-modem segítségével sorosporton keresztül küldöm a megfelelõ portra. 

\begin{figure}[!ht]
	\centering
	\resizebox{10cm}{!}{
		\includegraphics{figures/comnull.png}}
	\caption{}
	\label{fig:comnull}
\end{figure}

Beállítottam 2 párt, COM20-COM21 és COM10-COM11 közt, a pároson küldöm, páratlanon fogadom az üzeneteket. 

\begin{figure}[!ht]
	\centering
	\resizebox{10cm}{!}{
		\includegraphics{figures/sorossend.png}}
	\caption{}
	\label{fig:sorossend}
\end{figure}

153 bájtos egy csomag, melyet egy UUT  3 bájtos fejléc és egy 2 bájtos checksum zár. A checksum a hasznos bájtok 16 bitre csonkolt összege. Minden fogadott csomagnál, a feldolgozás elõtt kiszámolom az összeget és ellenõrzöm, az egyezést, a rossz csomagok egyelõre eldobásra kerülnek.

\begin{figure}[!ht]
	\centering
	\resizebox{10cm}{!}{
		\includegraphics{figures/xvi.png}}
	\caption{}
	\label{fig:xvi}
\end{figure}

Fogadó oldalon a két sorosport aszinkron ír 1-1 byte tömböt, melybõl egy dekódoló függvénnyel nyerjük ki a sebesség, pozíció, irány, stb. adatokat.

\begin{verbatim}
public double[] Decode(byte[] array)
\end{verbatim}

Ebben a függvényben ellenõrzöm, a checksum-ot, illetve a kezdõ UUT bájt hármast.
Mivel bájtosával lehet feldolgozni az adatokat, így pl. a 4 bájtos idõbélyeget 4 db egymás után jövõ bájtból kell összerakni:

\begin{verbatim}
uint ido = (uint)array[3]<<24 | (uint)array[4]<<16 |
(uint)array[5]<<8 | (uint)array[6];
\end{verbatim}

Ugyanígy folytatódik az adatok feldolgozása, az elõre megadott protokoll szerint.


