%----------------------------------------------------------------------------
\chapter{Megvalósítás}
%--------------------------------------

Az elõzõ fejezetekben összegyûjtöttem a megvalósításhoz szükséges információkat, tervezési lépéseket. Ebben a fejezetben a konkrét implementációt fogom bemutatni.


\section{Program felépítése}

A \figref{class} ábrán láthatóak a programban használt osztályok. A \textit{Program} statikus osztály a main függvényt, mint belépési pontot tartalmazza. Ez példányosítja az \textit{Instruments} osztályt, mely a különbözõ \textit{View}-ok megjelenítéséért felelõs. Az \textit{Altimeter, Compass, Speed, Vario} a mûszereket megvalósító osztályok, a PlanView a tervezõképernyõ, az \textit{ErrorOverview} osztály a diagnosztikai képernyõ implementációja. A soros portból érkezõ adatokat a \textit{SerialUtil} statikus osztály dolgozza fel, a kapott csomag egy-egy adattagját egy \textit{DataElement} objektumba helyezi, mely a hibadiagnosztikát valósítja meg a benne található elemre.

\begin{figure}[H]
	\centering
	\resizebox{13cm}{!}{
		\includegraphics{figures/classdiagram.png}}
	\caption{}
	\label{fig:class}
\end{figure}

\subsection{Kapcsolódás megvalósítása}

A \sectref{fejlesztes} fejezetben biztosítom a program számára a küldõ és fogadó oldalt, mely a repülõgépet hivatott helyettesíteni. A kapott adatok soros porton keresztül érkeznek, egy elõre meghatározott protokoll szerint (\sectref{protokoll} fejezet. A kapcsolódást megkönnyíti az elõre elkészített \textit{SerialPort} könyvtár csomag, mely minden szükséges mûveletet rendelkezésre bocsájt. Eseményvezérelt mûveletei közé tartozik a \textit{DataReceived()} függvény, mely akkor hívódik meg, ha a felépített kapcsolaton keresztül adat érkezett. Jelen esetben a kapcsolat sebességén múlhat, hogy egy ilyen adatcsomagban egy egész számunkra megfelelõ csomag érkezett-e. Elõfordulhat az az eset, hogy a repülõgép már küldi az adatait és a program ennek az adatfolyamnak a közepébe kapcsolódik bele, így egy elõzõ csomag eleje és a következõ csomag vége lemaradhat. Ezért szükséges egy puffert alkalmazni, melynek végére minden egyes beérkezõ bitet elrak, ha a puffer mérete elérte a fogadandó csomag kétszeresét, biztosak lehetünk abban, hogy ebbe egy csomag már belefér. Ekkor a puffer elejérõl egy iteráció elindul, mely az ``UUT'' fejlécet keresi, ha megtalálta, onnan a megtalált index + csomag hossza indexig iterálva feltölt egy byte tömböt, melyet a \textit{SerialUtil} osztály \textit{Decode()} függvénye fogad.


\subsection{Redundáns adatok feldolgozása}

Mivel párhuzamos csatornákon kapja az adatokat, így az elõzõ fejezetben ismertetett folyamat kétszerezve van, két külön soros portra. Végeredményben a kapott, értelmezhetõ megfelelõ fejléccel kezdõdõ csomagokat a \textit{SerialUtil.Decode()} függvény alakít át double értékekké, mellyel már kényelmesen lehet dolgozni. A dekódolás után minden egyes érték egy hozzá tartozó \textit{DataElement} objektumban tárolódik, az ezeket tartalmazó tömb a 2 port számára közös erõforrás, így a kölcsönös kizárásról gondoskodni kell. Mivel egy tömb írása nem atomi mûvelet, így a preemtív ütemezéssel ellátott operációs rendszer a portokhoz tartozó szálakat bármikor megszakíthatja, így elõfordulhat az az eset, hogy egyik soros portból érkezõ csomagot a dekódolás után éppen írja az egyik szál, közben a másik porthoz tatozó másik szál is elkezdené írni. Ezt elkerülendõ egy Lock objektumon történik a zárolás az írás megkezdésekor, melyet az írás befejezése szabadít fel, míg az objektum zárolt van, a másik szál kénytelen várakozni.

\subsection{Redundáns adatok hibadetektációja}

Minden fogadott adat egy \textit{DataElement} objektumban tárolódik, ebben 2 FIFO lista szerepel, egyik az ``A'', másik a ``B'' portból érkezõeknek. Mikor ``A''-ból érkezik egy, az \textit{AddA(double item)} függvény teszi bele az ``A'' FIFO végére, ugyanez a másik portra is érvényes. Mikor egy mûszer elkéri az értéket, melyet mutatni szeretne, akkor a \textit{GetData()} függvényhívással megkapja. A hibakezelés ezen függvényekben van megoldva, mindkettõ FIFO sor rendelkezik egy hibaszámlálóval, mely különbözõ feltételek mellett nõ vagy csökken. A \textit{GetData()} függvény aszerint, hogy mely sornak kisebb ez a hibaszámlálója, dönti el, hogy melyikbõl választaja ki az elemet.
A \sectref{terv_diagkepernyo} fejezetben ismertetett hibatípusokat a következõ detektációs algoritmusok érzékelik:

\textbf{Port kiesése:} Ha egyik porton érkezõ adat és érvényes csomag és azt dekódolás után a hozzátartozó tárolóba teszem, akkor egy számlálót is növelek. Amelyik porton érkezett az adat annak a számlálóját nullázom, így ha csak az egyik portról érkezik adat, akkor csak a másik számlálója növekszik. Ha ez a számláló elérte a FIFO sor méretét, akkor növekszik az adott port hibaszámlálója, ez a port kiesését jelenti.

\textbf{Beragadás:} Egy jelet akkor tekintek beragadt állapotúnak, ha értéke egy bizonyos ideig változatlan marad, jelen esetben a tároló körbefordulási ideje. Ha a sor legutóbbi és a legújabb eleme közti különbség egy $\epsilon$\footnote{ez esetben 0.0001}-nál kisebb, akkor növelem a port hibaszámlálóját.

\textbf{Túl nagy ugrás:}   TODO

\textbf{Kettõ jel eltérése:} TODO

\section{Megjelenítés}

Bal oldalon a létrehozott \textit{UserControl}-ok megjelenítése és elhelyezése a \figref{fokepernyo} ábrán látható. A terület nagyobb részét a térkép foglalja el, melyen a repülõgép aktuális pozíciója látható, illetve a múltban fogadott koordináták tört vonallal összekötve, mely a lerepült útvonalat ábrázolja. A program minimális méretében minden mûszer látszódik, a méret módosításával ezek fix pozícióban maradnak, a jobb oldali térkép a jobb alsó sarokhoz van horgonyozva, így ha nagyobb területen szeretné bárki is szemlélni a térképet, akkor látszódik ennek a megoldásnak az elõnye.

\subsection{Fõképernyõ}

A HappyKillmore (\sectref{happy} fejezet) forráskódjának tanulmányozása során látható, hogy minden mûszert külön View-ként valósít meg, így ezt a megoldást célszerû használni. Elkészítettem a magasságmérõ, emelkedésjelzõ, sebességmérõ és iránytû UserControll-t melyek tervezõ nézetben ``Drag and Drop'' technológiával a megfelelõ helyre húzható és könnyen beköthetõ.

\begin{figure}[H]
	\centering
	\resizebox{15cm}{!}{
		\includegraphics{figures/fokepernyo.png}}
	\caption{}
	\label{fig:fokepernyo}
\end{figure}


\subsubsection{Sebességmérõ}
A \textit{View} egy \textit{UserControll}-ból származik, annak a \textit{OnPaint()} metódusát írom felül, melyben a mûszer különbözõ elemeit pozicionálom a megfelelõ helyre. Az \textit{OnPaint()} függvény minden olyan esetben meghívódik, mikor valamely része érvénytelenné, nem láthatóvá válik. Ekkor szükséges az elem újra rajzolása, ezt mi a View Invalidate() metódusával explicit is kiválthatjuk.
GDI+ segítségével egy piros kört rajzolok

\subsubsection{Iránytû}
Az iránytû felépítése hasonló , mint a sebességmérõ mûszernek, jelentõs változás az égtájak és a fokok forgatását végzõ transzformáció. Elõször a kiírandó karaktert a grafikai koordináta-rendszer középpontjába tolom el, ekkor lehetséges az adott szöggel történõ elforgatás, majd a megfelelõ helyre eltolás. Ez azt a látszatot kelti, mintha úgy lenne egy tárcsára felírva, hogy az csak akkor olvasható, amikor felsõ helyzetben van.
A kirajzolást végzõ grafikus megjelenítõ pipeline tulajdonsága miatt ezeket a mûveleteket fordított sorrendben kell elvégezni a \textit{private void DrawNumbers(Graphics g)} metódusban.



\subsubsection{Csatlakozás sáv}

A program grafikus felületén a különbözõ oldalak fülek segítségével válthatóak, ezek felett található a csatlakozáshoz szükséges sáv, mely mindig látszódik, hogy éppen csatlakozott-e a program a kiválasztott portokra. Csatlakozás elõtt lehetõség van egy lenyíló listából a portokat és a jelsebességeket kiválasztani. Mivel valószínûsíthetõ, hogy a 2 port azonos sebességgel kommunikál, így az elsõ kiválasztásával a második is átállítódik, persze ha ez az eset mégsem állna fenn, az külön módosítható.


\subsubsection{Térképes vizualizáció}

A felület jobb oldalán egy Google Maps alapú térkép látható, melyet a GMap.NET API segítségével jelenítek meg. A térképre egy réteget helyeztem el, melyre a fogadott GPS pozíciókat törött vonallal összekötve rajzolom ki a gép által lerepült nyomvonalat, illetve a repülõt szimbolizáló \textit{planeMarker} ikont is a legutóbb kapott pozícióra állítom. 
Az ezt megvalósító programrészlet:
\begin{verbatim}
void AddCoordinate(PointLatLng receivedCoordinate)
{			
     flightRoute.Points.Add(receivedCoordinate);
     gmap.UpdateRouteLocalPosition(flightRoute);
     planeMarker.Position = receivedCoordinate;
     gmap.Invalidate();
}
\end{verbatim}

A \textit{planeMarker} ikont, a fogadott mágneses irány szerint elforgatom, így látszódik a repülõ haladási iránya is. A mágneses irányt a kapott Euler szög ``psi'' értékével állítom be.

A térkép egy lokális cache-bõl töltõdik be, mely Budapest környékét nagy felbontásban, Magyarországot közepes felbontásban tartalmazza, így a terepen, a program mûködõképes lesz internet kapcsolat nélkül is. Ha szükséges újabb területeket hozzáadni, az a mellékelt GMapDemo.WindowsForms.exe programmal könnyen megtehetõ, a generált könyvtárstruktúrával felül kell írni a program által használtat, bõvebb információ a \sectref{gmap} fejezetben található.



\subsection{Tervezés képernyõ}

A tervezõ képernyõn lehetséges az útvonal kijelölése és feltöltése, új útvonalpont a felületen dupla egérkattintással rakható le, mely hosszan nyomva szerkeszthetõ, jobb kattintással törölhetõ. A pontokat összekötõ szakaszok hosszát jobb oldalt megjelenítem és összegzem. A feltöltés gombra kattintva, az útvonalpontokat tartalmazó listát átadom a SerialUtil.Code() függvénynek, mely a \sectref{up_prot} fejezetben ismertetett protokoll szerint átalakítja bináris formába, ezt az átalakított byte tömböt küldöm el mindkettõ soros portra. Mivel az útvonal maximum 10 db pontot tartalmazhat, ezért új pont lerakásánál ezt szükséges ellenõrizni.
\begingroup
    \fontsize{10pt}{12pt}\selectfont
			\begin{verbatim}
			private void gmap_plan_MouseDoubleClick(object sender, MouseEventArgs e)
			{
				 if (plannedRoute.Points.Count < MAX_POINTS && e.Button == MouseButtons.Left)
				 {
					     PointLatLng currentPos = new PointLatLng(gmap_plan.FromLocalToLatLng(e.X, e.Y).Lat,
                                             gmap_plan.FromLocalToLatLng(e.X, e.Y).Lng);
					     GMarkerGoogle marker = new GMarkerGoogle(currentPos, GMarkerGoogleType.blue_small);
					     marker.ToolTipText = (numberOfPoints++).ToString();
					     planeMarkerOverlay.Markers.Add(marker);
					     markerOverlay.Markers.Add(marker);
					     plannedRoute.Points.Add(currentPos);
					     planView.Invalidate();
				 }
			}
			\end{verbatim}
\endgroup

Útvonalpont szerkesztésénél vizsgálni kell, hogy a kurzor aktuális pozíciója egy lerakott pont közelében van-e, ha igen és bal kattintás történik, akkor törölni kell a régi pontot a hozzá kapcsolódó élekkel együtt és új pontot kell létrehozni az aktuális pozícióban.

\begin{figure}[H]
	\centering
	\resizebox{15cm}{!}{
		\includegraphics{figures/tervkepernyo.png}}
	\caption{}
	\label{fig:tervkepernyo}
\end{figure}

\subsection{Diagnosztikai képernyõ}

A diagnosztikai képernyõn a portokon érkezõ adatok és hozzájuk tatozó hibaszámláló látható. Ha az egyik érték hibaszámlálója elér egy kritikus szintet, akkor pirossá válik és egy felugró ablakon figyelmezteti az operátort, hogy valamilyen hiba történt. Õ eldöntheti, hogy ez csak az egyik mûszer meghibásodása vagy esetleg egy fontos összetevõ kiesését jelenti. Ennek függvényében mérlegelhet, hogy a repülõ folytathatja-e a küldetését vagy érdemes kézi vezérlésre váltani és landolni.

\begin{figure}[H]
	\centering
	\resizebox{15cm}{!}{
		\includegraphics{figures/diagkepernyo.png}}
	\caption{}
	\label{fig:diagkepernyo}
\end{figure}


\subsection{Terminál képernyõ}

A fogadott csomagokat a terminál képernyõ jeleníti meg, ha nem jelennének meg adatok az elõzõ képernyõkön, akkor itt megbizonyosodhat a felhasználó, hogy a program fogadja-e a csomagokat. Ez a legalacsonyabb szintû kijelzés, ez csak a nyerj bájtokat iratja ki, választhatóan hexadecimális vagy decimális formában. Ha itt sincs változás, érdemes a csatlakoztatott portot vagy a jelsebességet változtatni.

\begin{figure}[H]
	\centering
	\resizebox{15cm}{!}{
		\includegraphics{figures/terminalkepernyo.png}}
	\caption{}
	\label{fig:terminalkepernyo}
\end{figure}

\section{Fejlesztés menete}
\label{sect:fejlesztes}
Az önálló, otthoni fejlesztést megkönnyítendõ, a repülõgép HIL\footnote{Hardware In the Loop, todo} szimulációjából nyert log file-okat használtam fel, így nem volt szükséges ez idõ alatt a repülõ közelében lennem, elég volt csak a végleges stádiumban kipróbálni a mûködést. A kapott file-ok felhasználásához elõször is biztosítani kellett, hogy a fejlesztendõ program soros porton keresztül ugyanúgy fogadhassa a csomagokat, mintha azt a repülõgép modemei küldenék. Ehhez készítettem 1-1 programot melyek ezeket a file-okat beolvassák és két kiválasztott soros portra 500 ms-onként egy csomagot küldenek, melyet egy emulátor programmal hoztam létre. Ez az emulátor \cite{bib:null} képes null-modemként viselkedni, melynek lényege, hogy software-es úton biztosít két soros port között kapcsolatot. Így létrehoztam egy COM20-COM21 és egy COM10-COM11 összeköttetést, az egyik program a COM20-ra másik a COM10-re csatlakozik, a fejlesztendõ program ezen párok másik portját használja kommunikációra. Mivel szükséges a kétirányú kapcsolat kiépítése, így a log file-okat feldolgozó programba beépítésre került egy beérkezõ üzeneteket feldolgozó függvény, mely kiírja a konzolos felületére a beérkezett csomagot, így ellenõrizhetõ, hogy azt küldi-e el amit szeretnék.

\begin{figure}[H]
	\centering	
	\begin{minipage}[b]{0.45\linewidth}
		\resizebox{7cm}{!}{
			\includegraphics{figures/comnull.png}}
		\caption{}
	\label{fig:comnull}
	\end{minipage}
	\quad
	\begin{minipage}[b]{0.45\linewidth}
		\resizebox{7cm}{!}{
			\includegraphics{figures/sorossend.png}}
		\caption{}
		\label{fig:sorossend}
	\end{minipage}
\end{figure}

A kapott log file-ok szerkezetét XVI32 nevû programmal tanulmányoztam és ismertem meg egy csomag felépítését és méretét. Látható, hogy egy csomag mérete valóban a specifikációban megadott 75 byte. Ezt a programot használtam az elküldött útvonalpontok csomagjának vizsgálatához is, hogy valóban úgy került-e elküldésre a csomag, ahogy azt a specifikációban meghatároztam.

\begin{figure}[H]
	\centering
	\resizebox{15cm}{!}{
		\includegraphics{figures/xvi.png}}
	\caption{}
	\label{fig:xvi}
\end{figure}
